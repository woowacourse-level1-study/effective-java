

## 로 타입은 사용하지 말자 - 아이템 26

<br>

클래스와 인터페이스 선언에 타입 매개변수(Type Paramter)가 사용되면, 이를 `제네릭 클래스 혹은 제네릭 인터페이스`라고 부르며 이를 통틀어 `제네릭 타입`이라고 한다.

<br>

각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스의 이름이 나오고, 바로 옆에 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다.

<br>

예를 들면, `List<String>`은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 여기서 `String`이 정규 타입 매개변수 `E`에 해당하는 실제 타입 매개변수이다.

<br>

그리고, 제네릭 타입을 하나 정의하면 그에 딸린 `로 타입`도 함께 정의된다. 이 `로 타입`이 바로 오늘 설명한 주제이다.

<br><br>



### 로 타입이란?

<hr>

로 타입이란, 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 코드로 설명하면 `List<E>`의 로 타입은 `List`이다.

<br>

로 타입은 타입선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭 도입이 되기 전인 자바 1.4 버전 이하의 코드와 호환되도록 하기 위한 궁여지책이라고 할 수 있다.

<br>

제네릭 지원 전에는 컬렉션은 다음과 같이 선언했다.

<br>

<img width="354" alt="스크린샷 2022-03-13 오전 11 52 21" src="https://user-images.githubusercontent.com/48710213/158042905-02bba181-8966-4daa-8800-809896de7bff.png">

<br>

해당 코드는 `Stamp` 타입만 저장을 하고 있다. 이때 루O 개발자가 실수로 `Coin`이라는 객체를 넣어버렸다. 과연 어떻게 될까??

<br>

<img width="424" alt="image" src="https://user-images.githubusercontent.com/48710213/158043122-2bd554d7-bd7a-4855-94ea-63ad6c22f21f.png">

<br>

아무 오류가 발생하지 않는다. 이대로 실행을 하고 해당 메서드를 호출하는 시점에 런타임에러`(ClassCastException)`가 발생하게 된다.

<br> 

<img width="565" alt="스크린샷 2022-03-13 오전 1 41 24" src="https://user-images.githubusercontent.com/48710213/158042842-bf69157c-96d4-4276-b2e5-3bd2722574a4.png">

<br>

즉, 오류가 발생하고 한참 뒤인 런타임에야 해당 오류를 발견할 수 있는데, 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 떨어져 있을 가능성이 커지게 된다.

<br>

제네릭을 활용하면 이러한 문제를 해결할 수 있게 된다.

<br>

<img width="500" alt="image" src="https://user-images.githubusercontent.com/48710213/158043096-e745bdff-f535-49c4-b430-727fd17e09f2.png">

<br>

이렇게 선언하면 컴파일러는 stamps에는`Stamp` 인스턴스만 넣어야 함을 인지하게 된다. 이제 stamps에 엉뚱한 타입의 인스턴스를 넣으면 컴파일 오류가 발생하며 무엇이 잘못되었는지를 정확하게 알려준다.

<br>

즉, 정리하자면 로 타입을 사용하는 것을 자바 언어 차원에서 막아 놓지는 않았지만 사용하지 않는 것을 권장하며 그 이유는 앞선 코드에서 보았듯이 **로 타입 사용시 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 되기 때문**으로 정리할 수 있다.

<br>

그럼 왜 이런 로 타입이 존재하는가에 대한 의문이 생기게 되는데 바로 `호환성 때문`이다. 자바 1.4 이하 버전에 작성된 코드와의 마이그레이션 호환성을 지켜주기 위해서 `타입 이레이저`라는 방식을 사용하여 호환성을 지켜주고 있다.

<br><br>


### 로 타입을 사용하고 싶을 경우에는?

<hr>

두 개의 `Set`에 같은 원소가 몇 개 있는지 반환하는 메서드를 만든다고 한다면, 어떤 매개변수가 들어오든 상관이 없다. 따라서 로 타입을 사용해도 괜찮지 않을까 라는 생각을 할 수 있다.

<br>

<img width="427" alt="image" src="https://user-images.githubusercontent.com/48710213/158043695-3992a491-d72f-4d5e-8b0a-b4fe642a99f3.png">

<br>

하지만 로 타입은 역시 안전하지 않다. 그러면 이러한 경우 어떻게 해야할까??

<br>

비한정적 와일드카드 타입을 사용하면 된다. 비한정적 와일드카드 타입은 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 `Set` 타입이다.

<br>

<img width="468" alt="image" src="https://user-images.githubusercontent.com/48710213/158043755-9433d878-4693-4158-b275-98259c607470.png">

<br>

그렇다면 로 타입과 비한정적 와일드카드 타입은 무슨 차이가 있는 것일까??

<br>

앞서 말했듯이, 로 타입에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기가 쉽다. 반면 비한정적 와일드카드는 null을 제외한 어떤 원소도 넣을 수 없다. 즉, 다른 원소를 넣으려 하면 컴파일할 때 에러를 발생하게 된다.


<br><br>

### 그럼에도 로 타입이 사용되는 곳이 있다면??

<hr>

로 타입을 쓰지 말라는 규칙에도 몇가지의 예외가 있다.

<br>

<u>첫번째 예외는 class 리터럴에는 로 타입을 사용해야 한다.</u>

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.

<img width="462" alt="image" src="https://user-images.githubusercontent.com/48710213/158043244-c6bb20a4-a5b5-4def-a382-772df9fa448e.png">

* 허용 : List.class, String[] class, int class
* 혀용하지 않음 : List<String>.class, List<?>.class

<br>

<u>두번째 예외는 `instanceof` 연산자 이다.</u>


런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 로 타입이든 비한정적 와일드카드 타입이든 완전히 동일하게 동작하게 된다.

<img width="442" alt="image" src="https://user-images.githubusercontent.com/48710213/158043269-97768046-1af3-4afc-b5e7-0b9ed176eb9a.png">

즉, `<?>` 은 코드의 가독성을 떨어트리게 되므로 차라리 `로 타입`을 사용하는 것이 좋을 수 있다.
 
  
<br><br>
  
### 최종 결론
  
<hr>
  
* 로 타입은 제네릭이 도입되기 전 코드와의 호환성을 위해 제공될 뿐이다.
  
* 로 타입은 런타임에 예외가 발생할 수 있으니 되도록 사용을 하지 말도록 하자.

