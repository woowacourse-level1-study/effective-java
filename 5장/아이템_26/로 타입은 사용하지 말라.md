

## 로 타입은 사용하지 말자 - 아이템 26

<hr>
<br>

클래스와 인터페이스 선언에 타입 매개변수(Type Paramter)가 사용되면, 이를 `제네릭 클래스 혹은 제네릭 인터페이스`라고 부르며 이를 통틀어 `제네릭 타입`이라고 한다.

<br><br>

각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스의 이름이 나오고, 바로 옆에 꺾쇠괄호 안에 실제 타입 매개변수들을 나열한다.

<br><br>

예를 들면, `List<String>`은 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입이다. 여기서 `String`이 정규 타입 매개변수 `E`에 해당하는 실제 타입 매개변수이다.

<br><br>

그리고, 제네릭 타입을 하나 정의하면 그에 딸린 `로 타입`도 함께 정의된다. 이 `로 타입`이 바로 오늘 설명한 주제이다.

<br><br>



### 로 타입이란?

<hr>

로 타입이란, 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 코드로 설명하면 `List<E>`의 로 타입은 `List`이다.

<br><br>

로 타입은 타입선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭 도입이 되기 전인 자바 1.4 버전 이하의 코드와 호환되도록 하기 위한 궁여지책이라고 할 수 있다.


<br><br>

제네릭 지원 전에는 컬렉션은 다음과 같이 선언했다.

<br>



<br>

해당 코드는 `Stamp` 타입만 저장을 하고 있다. 이때 루O 개발자가 실수로 `Coin`이라는 객체를 넣어버렸다. 과연 어떻게 될까??

<br><br>

아무 오류가 발생하지 않는다. 이대로 실행을 하고 해당 메서드를 호출하는 시점에 런타임에러`(ClassCastException)`가 발생하게 된다.




즉, 오류가 발생하고 한참 뒤인 런타임에야 해당 오류를 발견할 수 있는데, 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 떨어져 있을 가능성이 커지게 된다.

<br><br>

제네릭을 활용하면 이러한 문제를 해결할 수 있게 된다.

<br>


<br>

이렇게 선언하면 컴파일러는 stamps에는 Stamp 인스턴스만 넣어야 함을 인지하게 된다. 이제 stamps에 엉뚱한 타입의 인스턴스를 넣으면 컴파일 오류가 발생하며 무엇이 잘못되었는지를 정확하게 알려준다.


<br><br>

### 로 타입을 절대 사용하지 말자

<hr>

앞서서 말했듯이, 로 타입을 쓰는 걸 자바 언어 차원에서 막아 놓지는 않았지만 절대로 사용해서는 안된다. **로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.**

<br><br>

그럼 왜 이런 로 타입이 존재하는가에 대한 의문이 생기게 되는데 바로 `호환성 때문`이다. 자바 1.4 이하 버전에 작성된 코드와의 마이그레이션 호환성을 지켜주기 위해서 `타입 이레이저`라는 방식을 사용하여 호환성을 지켜주고 있다.

<br><br>

해당 코드를 통해 확인해도록 하자. 코드는 매개변수를 로 타입으로 사용한 예시이다.

<br>



<br>

해당 코드는 과연 재대로 동작은 할 것인가? 로 타입을 사용해 매우 불안정하다.

실제로 다음과 같이 `String` 타입에 `int` 타입을 넣어 런타임 에러를 발생시킨다.

따라서 이러한 문제 해결을 위해 `비한정 와일드카드` 타입을 대신 사용하는 것이 좋다.

<br>




<br>

> 비한정 와일드카드

와일드카드 문자인 `?` 만 사용할 때 비한정적 와일드카드라고 하며, 알려지지 않은 타입의 리스트라고도 부른다.

비한정 와일드카드는 값으로 `null` 만 삽입 될 수 있다.




<br><br>

### 그럼에도 로 타입이 사용되는 곳이 있다면??

<hr>

로 타입을 쓰지 말라는 규칙에도 몇가지의 예외가 있다.

<br><br>

<u>첫번째 예외는 class 리터럴에는 로 타입을 사용해야 한다.</u>

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.

* 허용 : List.class, String[] class, int class
* 혀용하지 않음 : List<String>.class, List<?>.class

<br><br>


<u>두번째 예외는 `instanceof` 연산자 이다.</u>


런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 로 타입이든 비한정적 와일드카드 타입이든 완전히 동일하게 동작하게 된다.

즉, `<?>` 은 코드의 가독성을 떨어트리게 되므로 차라리 `로 타입`을 사용하는 것이 좋을 수 있다.


